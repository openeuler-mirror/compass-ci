#!/bin/bash
# SPDX-License-Identifier: MulanPSL-2.0+
# Copyright (c) 2025 Huawei Technologies Co., Ltd. All rights reserved.

# pull native arch latest, to workaround podman problem
# that uses the last pull for current machine
case $(arch) in
    x86_64)
        common_archs="arm64 amd64"
        ;;
    aarch64)
        common_archs="amd64 arm64"
        ;;
esac

# OS list format: docker-image multiple architectures
OS_LIST=(
    "openeuler/openeuler:24.09 $common_archs"
    "openeuler/openeuler:24.03 $common_archs"
    "openeuler/openeuler:22.03 $common_archs"
    "openeuler/openeuler:20.03 $common_archs"

    "opensuse/leap:15.6 $common_archs"

    "debian:12 $common_archs"
    "ubuntu:24.04 $common_archs"

    "fedora:42 $common_archs"
    "centos:9 $common_archs"
    "rockylinux:9 $common_archs"

    "alpine:3.21 $common_archs"

    "archlinux:latest $common_archs"
)

usage() {
    echo "Usage: $0 [--os <os_name>] [--help]"
    echo "  --os <os_name>   Specify the OS to process (e.g., 'alpine:3.21')"
    echo "  --help           Display this help message"
    exit 1
}

# Detect container runtime
CONTAINER_RUNTIME=$(command -v podman || command -v docker)
[ -n "$CONTAINER_RUNTIME" ] || {
    echo "Please install podman or docker"
    exit 1
}

# Check for fakeroot or root privileges
if which fakeroot >/dev/null 2>&1; then
    FAKEROOT=fakeroot
else
    FAKEROOT=
    [ -w /srv ] || {
        echo "Please install fakeroot or run as root"
        exit 1
    }
fi

# Determine base directory
if [ -w /srv ]; then
    BASE_DIR="/srv"
else
    BASE_DIR="$HOME/.cache/compass-ci"
fi

# Define output directory
OUTPUT_DIR=$BASE_DIR/file-store/docker2os/
mkdir -p "$OUTPUT_DIR"

# Logging function
log_message() {
    echo "[INFO] $1"
}

# Map architecture names (Docker -> Standard)
map_architecture() {
    case "$1" in
        arm64) echo "aarch64" ;;
        amd64) echo "x86_64" ;;
        *) echo "$1" ;; # Default to the input if no mapping exists
    esac
}

map_os_name() {
    # handle openeuler, opensuse
    OS_NAME=${OS_NAME%/*}

    case "$OS_NAME" in
        rockylinux)
            OS_NAME=rocky
            ;;
    esac
}

# Parse command-line arguments
SELECTED_OS=""
for arg in "$@"; do
    case "$arg" in
        --os)
            SELECTED_OS="$2"
            shift 2
            ;;
        --help)
            usage
            ;;
        *)
            echo "Unknown argument: $arg"
            usage
            ;;
    esac
done

# Validate selected OS
if [ -n "$SELECTED_OS" ]; then
    FOUND=0
    for entry in "${OS_LIST[@]}"; do
        IMAGE_NAME=$(echo "$entry" | awk '{print $1}')
        if [ "$IMAGE_NAME" == "$SELECTED_OS" ]; then
            FOUND=1
            break
        fi
    done
    if [ $FOUND -eq 0 ]; then
        echo "Error: Selected OS '$SELECTED_OS' not found in OS_LIST."
        exit 1
    fi
fi

# Process each OS, version, and architecture
for entry in "${OS_LIST[@]}"; do
    DOCKER_IMAGE=$(echo "$entry" | awk '{print $1}')
    ARCH_LIST=$(echo "$entry" | cut -d' ' -f2-)

    # Skip if a specific OS is selected and it doesn't match
    if [ -n "$SELECTED_OS" ] && [ "$DOCKER_IMAGE" != "$SELECTED_OS" ]; then
        continue
    fi

    # Extract OS name and version
    OS_NAME=$(echo "$DOCKER_IMAGE" | cut -d':' -f1)
    OS_VERSION=$(echo "$DOCKER_IMAGE" | cut -d':' -f2)

    map_os_name
    log_message "Processing OS: $OS_NAME, Version: $OS_VERSION"

    # Process each architecture
    for DOCKER_ARCH in $ARCH_LIST; do
        MAPPED_ARCH=$(map_architecture "$DOCKER_ARCH")
        OUTPUT_FILE="${MAPPED_ARCH}/${OS_NAME}@${OS_VERSION}.cgz"

        # Skip if the output file already exists
        if [ -e "$OUTPUT_DIR/$OUTPUT_FILE" ]; then
            log_message "Skipping existing file: $OUTPUT_FILE"
            continue
        fi

        mkdir -p "$OUTPUT_DIR/$MAPPED_ARCH"

        log_message "Processing: Arch=$DOCKER_ARCH (Mapped: $MAPPED_ARCH)"

        # Step 1: Pull the Docker image for the specified platform
        if ! $CONTAINER_RUNTIME images --format "{{.Repository}}:{{.Tag}}" | grep -q "$DOCKER_IMAGE$"; then
            log_message "Pulling Docker image '$DOCKER_IMAGE' for platform '$DOCKER_ARCH'..."
            if ! $CONTAINER_RUNTIME pull --platform "linux/$DOCKER_ARCH" "$DOCKER_IMAGE"; then
                log_message "Failed to pull Docker image '$DOCKER_IMAGE' for platform '$DOCKER_ARCH'. Skipping."
                continue
            fi
        fi

        # Step 2: Create a temporary container from the image
        log_message "Creating a temporary container from the image..."
        CONTAINER_ID=$($CONTAINER_RUNTIME create --platform "linux/$DOCKER_ARCH" "$DOCKER_IMAGE")
        if [ -z "$CONTAINER_ID" ]; then
            log_message "Failed to create a container from the image. Skipping."
            continue
        fi

        # Step 3: Export the container's filesystem and package it into a cpio.gz archive
        TEMP_DIR="/tmp/$CONTAINER_ID"
        mkdir -p "$TEMP_DIR"
        log_message "Exporting and packaging the container's filesystem into a cpio.gz archive..."
        $CONTAINER_RUNTIME export "$CONTAINER_ID" | fakeroot sh -c "tar -C $TEMP_DIR -xf - && cd $TEMP_DIR && find | cpio -o -H newc | gzip -9 > $OUTPUT_DIR/$OUTPUT_FILE"

        if [ $? -ne 0 ]; then
            log_message "Failed to export or package the container's filesystem. Skipping."
            $CONTAINER_RUNTIME rm -f "$CONTAINER_ID" > /dev/null 2>&1
            rm -fr "$TEMP_DIR" > /dev/null 2>&1
            continue
        fi

        # Step 4: Remove the temporary container
        log_message "Removing the temporary container..."
        $CONTAINER_RUNTIME rm -f "$CONTAINER_ID" > /dev/null 2>&1
        rm -fr "$TEMP_DIR" > /dev/null 2>&1

        log_message "Initrd created successfully: '$OUTPUT_DIR/$OUTPUT_FILE'"
    done
done

# remove dangling ones
# $CONTAINER_RUNTIME images -f "dangling=true"
$CONTAINER_RUNTIME image prune -f

log_message "All tasks completed. Output files are in '$OUTPUT_DIR'."

# vim:set ts=4 sw=4 et:
