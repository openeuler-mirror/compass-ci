#!/usr/bin/ruby
# frozen_string_literal: true

require 'optparse'
require_relative '../lib/manticore.rb'

options = { index: Manticore::DEFAULT_INDEX, size: 10 }
opt_parser = OptionParser.new do |opts|
  opts.banner = <<~HELP
    Usage: manti-find [options] key1=val1,val2...
    Examples:
      manti-find suite=pkgbuild testbox=vm-2p8g
      manti-find -t submit_time=3d
      manti-find -t submit_time=2024-01-01,2024-02-01
      manti-find --sql "SELECT suite,osv,my_account,testbox,boot_time FROM jobs WHERE id=123"
      manti-find -t 9d -t +3d  # will expand to -t time=now-9d -t time=,now-3d
  HELP

  opts.on('-i', '--index INDEX', "Index name (default: #{Manticore::DEFAULT_INDEX})") { |i| options[:index] = i }
  opts.on('-n', '--size NUM', Integer, "Results limit (default: 10)") { |n| options[:size] = n }
  opts.on('-t', '--time RANGE', "Time range filter") { |t| (options[:ranges] ||= []) << t }
  opts.on('-d', '--desc KEY', "Sort key (default: submit_time)") { |d| options[:sort] = d }
  opts.on('-S', '--sql CMD', "Raw SQL command") { |s| options[:sql] = s }
  opts.on('-s', '--select CMD', "SQL SELECT command") { |s| options[:select] = s }
  opts.on('--mapping', "Show index mapping") { options[:mapping] = true }
  opts.on('-h', '--help', "Show help") { puts opts; exit }
end

begin
  remaining_args = opt_parser.parse!

  if options[:sql]
    filtered_sql = Manticore.filter_sql_fields(options[:sql])
    body = Manticore.filter_sql_result(Manticore::Client.execute_sql(filtered_sql).body)
    puts JSON.pretty_generate(JSON.parse(body))
    exit
  end

  if options[:select]
    filtered_sql = Manticore.filter_sql_fields(options[:select])
    body = Manticore::Client.execute_select(filtered_sql).body
    puts JSON.pretty_generate(JSON.parse(body))
    exit
  end

  if options[:mapping]
    body = Manticore::Client.execute_sql("DESC #{options[:index]}").body
    puts JSON.pretty_generate(JSON.parse(body))
    exit
  end

  query_builder = Manticore::QueryBuilder.new(index: options[:index], size: options[:size])

  # Parse key-value arguments
  remaining_args.each do |arg|
    next unless arg.include?('=')
    field, values = arg.split('=', 2)
    query_builder.add_filter(field, values.split(','))
  end

  # Add time ranges
  if options[:ranges]
    Manticore::TimeParser.parse_range(options[:ranges]).each do |field, range|
      query_builder.add_range(field, **range)
    end
  end

  # Add sorting
  sort_field = options[:sort] || 'submit_time'
  query_builder.sort(sort_field, order: 'desc')

  # Execute search
  response = Manticore::Client.search(query_builder.build)
  puts JSON.pretty_generate(JSON.parse(response.body))

rescue => e
  warn "Error: #{e.message}"
  exit 1
end
